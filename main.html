<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Falling Items — Game</title>
  <style>
    :root{
      --ui: #ffd700;
      --ui-soft: rgba(255,215,0,.18);
      --glow: #6fe7ff;
    }
    html,body{height:100%}
    body{
      margin:0;
      background: transparent;
      color:#fff;
      overflow:hidden;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    #game{
      position:relative;
      width:100%;
      height:100%;
      overflow:hidden;
    }

    /* ===== GLASS PRISM ОБЩИЙ СТИЛЬ ===== */
    .glass-pill{
      background:linear-gradient(135deg,rgba(10,12,35,.92),rgba(8,8,22,.78));
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      box-shadow:0 14px 40px rgba(0,0,0,.75);
      backdrop-filter:blur(18px) saturate(145%);
    }
    .glass-card{
      background:linear-gradient(135deg,rgba(10,12,35,.92),rgba(8,8,22,.78));
      border-radius:18px;
      border:1px solid rgba(255,255,255,.16);
      box-shadow:0 18px 42px rgba(0,0,0,.78);
      backdrop-filter:blur(20px) saturate(150%);
    }

    /* ===== HUD: таймер и счёт ===== */
    .hud-main{
      position:fixed;
      left:12px; right:12px; top:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      font-weight:700;
      z-index:10;
      pointer-events:none;
    }
    .badge{
      pointer-events:none;
      padding:8px 16px;
      font-size:16px;
      min-width:96px;
      text-align:center;
      color:#f5f5f5;
    }
    .badge.timer{ justify-self:flex-start }
    .badge.score{ justify-self:flex-end }

    /* ===== ВОПРОС — ПО ЦЕНТРУ СВЕРХУ ===== */
    .question-bar{
      position:fixed;
      top:70px;
      left:0; right:0;
      display:flex;
      justify-content:center;
      z-index:9;
      pointer-events:none;
      opacity:0;
      transform:translateY(-6px);
      transition:opacity .22s ease, transform .22s ease;
    }
    .question-bar.visible{
      opacity:1;
      transform:translateY(0);
    }
    .question-frame{
      position:relative;
      max-width:min(86vw,780px);
    }
    .question-bubble{
      padding:14px 22px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.16);
      background:linear-gradient(135deg,rgba(10,12,35,.92),rgba(6,6,20,.8));
      box-shadow:0 18px 42px rgba(0,0,0,.8);
      backdrop-filter:blur(18px) saturate(150%);
    }
    .hudQuestion{
      font-weight:500;
      line-height:1.25;
      max-height:4.5em;
      overflow:hidden;
      text-overflow:ellipsis;
      word-wrap:break-word;
      white-space:normal;
    }

    /* ===== СТАРТ/ФИНАЛ — ТОТ ЖЕ GLASS PRISM ===== */
    .overlay{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center; flex-direction:column;
      background:none;
      color:#fff; z-index:20; gap:18px;
      pointer-events:auto;
    }
    .overlay .panel{
      padding:22px 26px;
      min-width:min(92vw,540px);
    }
    .overlay h2{
      margin:6px 0 10px;
      font-size:24px; font-weight:900; color:var(--ui);
      text-shadow:0 0 20px var(--ui-soft);
    }
    .overlay p{ margin:0 0 8px; opacity:.9 }
    .overlay .row{ display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap }
    .overlay button{
      background:linear-gradient(135deg,#ffe79f,#ffd700);
      color:#000; border:0; border-radius:999px; font-weight:900; padding:12px 20px; cursor:pointer;
      transition:transform .12s ease, box-shadow .12s ease;
      pointer-events:auto;
      box-shadow:0 10px 28px rgba(0,0,0,.65);
    }
    .overlay button:hover{ transform:translateY(-1px); box-shadow:0 14px 34px rgba(0,0,0,.8) }

    /* Финальная карточка */
    .final-inner{
      padding:22px 26px;
      min-width:min(92vw,380px);
      text-align:center;
    }
    .final-title{
      font-size:26px;
      margin:0 0 10px;
      color:var(--ui);
      text-shadow:0 0 18px var(--ui-soft);
    }
    .final-main-score{
      font-size:32px;
      font-weight:800;
      margin-bottom:12px;
      text-shadow:0 0 18px rgba(255,255,255,.5);
    }
    .final-stats{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:6px 14px;
      text-align:left;
      font-size:15px;
      margin-bottom:18px;
    }
    .final-stats .label{opacity:.85}
    .final-stats .value{font-weight:700}
    .btn-final{
      background:linear-gradient(135deg,#ffe79f,#ffd700);
      color:#000;
      border:0;
      border-radius:999px;
      font-weight:900;
      padding:10px 22px;
      cursor:pointer;
      font-size:16px;
      box-shadow:0 10px 30px rgba(0,0,0,.7);
      transition:transform .12s ease, box-shadow .12s ease;
    }
    .btn-final:hover{
      transform:translateY(-1px);
      box-shadow:0 14px 36px rgba(0,0,0,.85);
    }

    /* ===== Падающие элементы ===== */
    .item{
      position:absolute;
      top:-160px; left:0;
      transform:translateZ(0);
      will-change:transform, top, left, width, height;
      display:inline-flex;
      align-items:center; justify-content:center;
      min-width:120px; min-height:80px;
      padding:0;
      user-select:none; cursor:pointer;
    }
    .item .bg{
      position:absolute; inset:0;
      background: transparent;
      opacity:1;
      border:0 solid #fff;
      box-shadow:none;
      transition:filter .15s ease;
      background-position:center !important;
      background-repeat:no-repeat !important;
      background-size:contain !important;
    }
    .item .content{
      position:relative; z-index:1;
      display:flex; align-items:center; justify-content:center;
      text-align:center; line-height:1.15;
      width: var(--cw, auto);
      height: var(--ch, auto);
    }
    .item .content span{
      display:inline-block;
      font-weight:800;
      white-space:nowrap;
    }
    .item .content .mjx-container{ font-size: inherit !important; }
    .item .content img{
      display:block;
      width:100%;
      height:100%;
      max-width:none;
      max-height:none;
      object-fit:contain;
      pointer-events:none;
    }
    .shape-rect    .bg{ border-radius:10px }
    .shape-rounded .bg{ border-radius:20px }
    .shape-circle  .bg{ border-radius:50% }
    .shape-diamond .bg{ clip-path:polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%) }
    .shape-star    .bg{
      clip-path: polygon(
        50% 0%, 61% 35%, 98% 35%,
        68% 57%, 79% 91%, 50% 70%,
        21% 91%, 32% 57%, 2% 35%, 39% 35%
      );
    }
    .poly-border { box-shadow: inset 0 0 0 var(--bw, 1px) var(--bc, #fff); }
    .shape-diamond.fx-shadow .bg,
    .shape-star.fx-shadow .bg{
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.55));
      box-shadow: none;
    }
    .shape-diamond.fx-glow .bg,
    .shape-star.fx-glow .bg{
      filter: drop-shadow(0 0 14px var(--glow, #00f0ff));
    }
    .shape-diamond.fx-3d .bg,
    .shape-star.fx-3d .bg{
      filter: drop-shadow(7px 7px 16px rgba(0,0,0,.55));
    }
    .fx-shadow .bg{ box-shadow:0 10px 30px rgba(0,0,0,.55) }
    .fx-3d     .bg{ box-shadow: 7px 7px 20px rgba(0,0,0,.55), inset -5px -5px 12px rgba(255,255,255,.22) }
    .fx-glow   .bg{ box-shadow:0 0 18px var(--glow, #00f0ff), 0 0 28px rgba(0,0,0,.25) }
    .fx-border .bg{ border-style:solid }

    /* Поп при ловле — БОЛЬШЕ */
    .caught{ animation:pop .6s ease-out forwards }
    @keyframes pop{
      0%{   transform:scale(1);   opacity:1 }
      45%{  transform:scale(1.45);opacity:1 }
      100%{ transform:scale(.15); opacity:0 }
    }

    /* Блёстки */
    .sparkle{
      position:absolute; width:7px; height:7px; border-radius:50%;
      background:rgba(255,255,255,.95); pointer-events:none;
      animation:spark 0.9s forwards;
      filter:drop-shadow(0 0 8px #fff); z-index:5;
    }
    @keyframes spark{
      from{ opacity:1; transform:translate(0,0) scale(1) }
      to  { opacity:0; transform:translate(var(--dx), var(--dy)) scale(.25) }
    }

    /* Всплывающие очки */
    .score-float{
      position:fixed; z-index:30;
      font-weight:900;
      text-shadow: 0 0 10px rgba(255,255,255,.5), 0 0 20px var(--ui-soft);
      animation:floatUp .9s ease-out forwards;
      pointer-events:none;
    }
    @keyframes floatUp{
      0%  { transform:translate(-50%,-8px); opacity:0 }
      10% { opacity:1; }
      100%{ transform:translate(-50%,-64px); opacity:0 }
    }

    /* Фейерверк */
    .firework{
      position:fixed; width:4px; height:4px; border-radius:50%;
      background:#fff; pointer-events:none; z-index:40; animation:fw 900ms ease-out forwards;
    }
    @keyframes fw{
      from{ transform:translate(0,0) scale(1); opacity:1 }
      to  { transform:translate(var(--tx), var(--ty)) scale(0.1); opacity:0 }
    }

    /* Красный тинт при ошибке */
    .tint-red .bg { animation: redTintOnly 550ms ease; }
    @keyframes redTintOnly {
      0%   { filter: none; }
      15%  { filter: hue-rotate(-25deg) saturate(3) brightness(1.2) contrast(1.2); }
      50%  { filter: hue-rotate(-10deg) saturate(2.5) brightness(1.1) contrast(1.1); }
      100% { filter: none; }
    }

    /* Подёргивание при ошибке (по bg, чтобы не ломать траекторию) */
    .shake .bg{ animation:shake .35s ease; }
    @keyframes shake{
      0%  { transform:translateX(0); }
      20% { transform:translateX(-6px); }
      40% { transform:translateX(6px); }
      60% { transform:translateX(-4px); }
      80% { transform:translateX(4px); }
      100%{ transform:translateX(0); }
    }
  </style>
  <script>
    function loadGoogleFont(fontName){
      if(!fontName) return;
      const family = fontName.replace(/ /g, '+');
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = `https://fonts.googleapis.com/css2?family=${family}:wght@400;700&display=swap`;
      document.head.appendChild(link);
    }
  </script>
</head>
<body>
  <!-- HUD: таймер и счёт -->
  <div class="hud-main">
    <div class="badge glass-pill timer" id="hudTimer">00:00</div>
    <div class="badge glass-pill score" id="hudScore">0</div>
  </div>

  <!-- ВОПРОС -->
  <div class="question-bar" id="questionBar">
    <div class="question-frame">
      <div class="question-bubble">
        <div class="hudQuestion" id="hudQuestion"></div>
      </div>
    </div>
  </div>

  <!-- Сцена -->
  <div id="game" aria-live="polite"></div>

  <!-- MathJax -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <script>
    /* ===== Локализация ===== */
    const I18N = {
      ru:{ startTitle:"Игра «Падающие элементы»", startBtn:"Начать",
        restartBtn:"Играть снова",
        time:"Время", score:"Счёт",
        gameComplete:"Игра пройдена!",
        hits:"Попаданий", wrong:"Мимо", missed:"Ушло правильных",
        finalFeedbackTitle:"Молодец!", defaultFinalFeedback:"Отличная работа!"
      },
      math:{
        startTitle:"Игра «Падающие элементы» (Математика)", startBtn:"Начать",
        restartBtn:"Играть снова",
        time:"Время", score:"Счёт",
        gameComplete:"Игра пройдена!",
        hits:"Попаданий", wrong:"Мимо", missed:"Ушло правильных",
        finalFeedbackTitle:"Молодец!", defaultFinalFeedback:"Отличная работа!"
      }
    };
    function t(lang,key,...args){
      const dict = I18N[lang]||I18N.ru; const v = dict[key];
      return (typeof v==="function")?v(...args):(v??key);
    }

    const $ = sel => document.querySelector(sel);
    const rnd = (a,b)=> a + Math.random()*(b-a);
    const clamp = (v,min,max)=> Math.max(min, Math.min(max,v));

    function hexToRgb(hex){
      let s = (hex||'').trim();
      if(!s) return {r:255,g:215,b:0};
      if(s[0]==='#') s=s.slice(1);
      if(s.length===3) s=s.split('').map(c=>c+c).join('');
      const n=parseInt(s,16);
      return {r:(n>>16)&255, g:(n>>8)&255, b:(n)&255};
    }

    const params = new URLSearchParams(location.search);
    const GAME_ID = params.get('id');
    const JSON_BASE = "https://nikashum93.github.io/texts/data/";

    let cfg = null;
    let LANG = 'ru';

    /* ===== HUD refs ===== */
    const hudTimer = $('#hudTimer');
    const hudScore = $('#hudScore');
    const hudQuestion = $('#hudQuestion');
    const questionBar = $('#questionBar');

    /* ===== Звук ===== */
    const popSound   = new Audio("pop.mp3");
    const wrongSound = new Audio("wrong.mp3");
    const winSound   = new Audio("win.mp3");

    /* ===== Глобальные статы ===== */
    let score = 0;
    let currentLevel = 0;
    let running = false;
    let globalTimerHandle = null;
    let globalTimeLeft = 0;
    let spawnerHandle = null;
    let hits = 0;
    let wrongClicks = 0;
    let missedCorrect = 0;
    let streak = 0;
    let currentQuestion = null;
    let neededCorrect = 0;
    let foundCorrect = new Set();
    let SPEED = { vel: 1.5, spawn: 1000, basePts: 20 };
    const WRONG_PENALTY = 10;

    /* ===== ФОНЫ ===== */
    let bgImgEl = null;

    (async function boot(){
      if(!GAME_ID){
        showFatal("Нет id", "Не передан id в строке запроса.");
        return;
      }
      try{
        const url = `${JSON_BASE}${encodeURIComponent(GAME_ID)}.json?v=${Date.now()}`;
        const res = await fetch(url, { cache:'no-store' });
        if(!res.ok) throw new Error('HTTP '+res.status);
        cfg = await res.json();
      }catch(e){
        showFatal("Ошибка загрузки", `Не удалось загрузить настройки: ${e.message}\nПроверь публикацию в texts/data.`);
        return;
      }

      LANG = (cfg.language || 'ru').toLowerCase();

      if(cfg.font)          loadGoogleFont(cfg.font);
      if(cfg.questionFont)  loadGoogleFont(cfg.questionFont);

      const uiColor = (cfg.style && (cfg.style.borderColor || cfg.style.glowColor)) || '#ffd700';
      const rgb = Object.values(hexToRgb(uiColor)).join(',');
      document.documentElement.style.setProperty('--ui', uiColor);
      document.documentElement.style.setProperty('--ui-soft', 'rgba('+rgb+',.18)');
      if (cfg.style && cfg.style.glowColor){
        document.documentElement.style.setProperty('--glow', cfg.style.glowColor);
      }
      if (cfg.cursor) document.body.style.cursor = `url(${cfg.cursor}), auto`;

      setupBackgrounds();
      setQuestionText(""); // скрываем до старта
      showStartOverlay();
    })();

    function setupBackgrounds(){
      const list = Array.isArray(cfg?.backgrounds) ? cfg.backgrounds.filter(Boolean) : [];
      if (!list.length){
        if (bgImgEl){ bgImgEl.remove(); bgImgEl = null; }
        return;
      }
      if (!bgImgEl){
        bgImgEl = document.createElement('img');
        Object.assign(bgImgEl.style, {
          position:'fixed', inset:'0', width:'100%', height:'100%',
          objectFit:'cover', zIndex:'-1', pointerEvents:'none'
        });
        document.body.prepend(bgImgEl);
      }
      const pick = () => list[Math.floor(Math.random()*list.length)];
      bgImgEl.src = pick();

      const _startLevel = startLevel;
      startLevel = function(){
        if (bgImgEl && bgImgEl.parentNode){
          const fresh = bgImgEl.cloneNode(false);
          fresh.src = pick();
          bgImgEl.parentNode.replaceChild(fresh, bgImgEl);
          bgImgEl = fresh;
        }
        _startLevel();
      };
    }

    /* ===== HUD / Оверлеи ===== */
    function setQuestionText(text){
      if (!hudQuestion || !questionBar) return;
      const lang = (cfg.language || 'ru').toLowerCase();
      const isMath = (lang === 'math');
      const qFont = cfg.questionFont || cfg.font || 'Rubik';
      const baseSize = Number(cfg.questionFontSize || 26);

      if (!text){
        hudQuestion.textContent = '';
        questionBar.classList.remove('visible');
        return;
      }

      if (isMath){
        hudQuestion.textContent = `\\(${text}\\)`;
        MathJax.typesetPromise([hudQuestion]);
      } else {
        hudQuestion.textContent = text;
      }

      const len = (text || '').length;
      let size = baseSize;
      if (!cfg.questionFontSize){
        if (len > 110) size = 18;
        else if (len > 60) size = 22;
      }
      hudQuestion.style.fontSize = size + 'px';
      hudQuestion.style.fontFamily = `${qFont}, system-ui, sans-serif`;

      questionBar.classList.add('visible');
    }

    function showFatal(title, message){
      const ov = document.createElement('div');
      ov.className = 'overlay';
      ov.innerHTML = `
        <div class="glass-card panel">
          <h2>${title}</h2>
          <p style="white-space:pre-wrap">${message}</p>
        </div>`;
      document.body.appendChild(ov);
    }

    function showStartOverlay(){
      const existing = document.querySelector('.overlay');
      if (existing) existing.remove();

      const ov = document.createElement('div');
      ov.className = 'overlay';

      const title  = (cfg.start && typeof cfg.start.title === 'string' && cfg.start.title.trim())
                     ? cfg.start.title.trim()
                     : t(LANG,'startTitle');
      const btnTxt = (cfg.start && typeof cfg.start.btnText === 'string' && cfg.start.btnText.trim())
                     ? cfg.start.btnText.trim()
                     : t(LANG,'startBtn');

      ov.innerHTML = `
        <div class="glass-card panel">
          <h2>${title}</h2>
          <p style="margin-top:4px; opacity:.85">Кликайте по всем правильным объектам.</p>
          <div class="row" style="margin-top:14px">
            <button id="btnStart">${btnTxt}</button>
          </div>
        </div>`;
      document.body.appendChild(ov);

      $('#btnStart').addEventListener('click', ()=>{
        ov.remove();
        startGame();
      }, { once: true });
    }

    function showGameCompleteOverlay(stats){
      const existing = document.querySelector('.overlay');
      if (existing) existing.remove();

      const ov = document.createElement('div');
      ov.className = 'overlay';

      const custom  = (cfg.finalFeedback || cfg.feedback || "").trim();
      const fbTitle = t(LANG,'finalFeedbackTitle');
      const fbText  = t(LANG,'defaultFinalFeedback');

      const sc = (stats && stats.score != null) ? stats.score : score;
      const h  = stats?.hits ?? hits;
      const w  = stats?.wrong ?? wrongClicks;
      const m  = stats?.missed ?? missedCorrect;

      ov.innerHTML = `
        <div class="glass-card final-inner">
          <h2 class="final-title">${t(LANG,'gameComplete')}</h2>
          ${
            custom
              ? `<p style="white-space:pre-wrap; margin:0 0 10px">${custom}</p>`
              : `<p style="margin:6px 0 10px; font-size:18px; color:var(--ui)">${fbTitle}</p>
                 <p style="white-space:pre-wrap; margin:0 0 4px">${fbText}</p>`
          }
          <div class="final-main-score">${sc}</div>
          <div class="final-stats">
            <div><span class="label">${t(LANG,'hits')}:</span> <span class="value">${h}</span></div>
            <div><span class="label">${t(LANG,'wrong')}:</span> <span class="value">${w}</span></div>
            <div><span class="label">${t(LANG,'missed')}:</span> <span class="value">${m}</span></div>
          </div>
          <button id="btnRestart" class="btn-final">${t(LANG,'restartBtn')}</button>
        </div>`;
      document.body.appendChild(ov);
      $('#btnRestart').addEventListener('click', ()=> location.reload(), { once:true });

      fireworks(); // финальный фейерверк
    }

    /* ===== Геймплей ===== */
    function computeSpeedParams(S){
      const s = clamp(Number(S||5), 1, 10);
      const vel = 0.65 + (s-1) * (6.2-0.65)/9;
      const spawn = 1700 - (s-1) * (1350)/9;
      const basePts = 8 + (s-1) * (50-8)/9;
      return { vel, spawn, basePts: Math.round(basePts) };
    }

    function shuffleCopy(arr){
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function startGame(){
      SPEED = computeSpeedParams(cfg?.speed ?? 5);
      score = 0;
      hits = 0;
      wrongClicks = 0;
      missedCorrect = 0;
      streak = 0;
      hudScore.textContent = '0';

      // Таймер
      if (globalTimerHandle){
        clearInterval(globalTimerHandle);
        globalTimerHandle = null;
      }
      globalTimeLeft = Number(cfg?.globalTimer || 0);

      if (globalTimeLeft > 0){
        hudTimer.style.display = '';
        hudTimer.textContent = formatTime(globalTimeLeft);
        globalTimerHandle = setInterval(()=>{
          if (!running) return;
          globalTimeLeft--;
          hudTimer.textContent = formatTime(globalTimeLeft);
          if (globalTimeLeft <= 0){
            clearInterval(globalTimerHandle);
            globalTimerHandle = null;
            running = false;
            stopSpawning();
            clearItems();
            fireworks();
            try{ winSound.currentTime=0; winSound.play(); }catch(_){}
            showGameCompleteOverlay({
              score,
              hits,
              wrong: wrongClicks,
              missed: missedCorrect
            });
          }
        }, 1000);
      } else {
        // нет таймера — просто скрываем
        hudTimer.style.display = 'none';
      }

      // рандом уровней по галочке
      if (cfg.randomLevels && Array.isArray(cfg.levels)) {
        cfg.levels = shuffleCopy(cfg.levels);
      }

      currentLevel = 0;
      running = true;
      startLevel();
    }

    function formatTime(sec){
      const m = Math.floor(sec / 60).toString().padStart(2,'0');
      const s = (sec % 60).toString().padStart(2,'0');
      return `${m}:${s}`;
    }

    function stopSpawning(){
      if (spawnerHandle){
        clearTimeout(spawnerHandle);
        spawnerHandle = null;
      }
    }

    function clearItems(){
      document.querySelectorAll('.item').forEach(n => n.remove());
    }

    function startLevel(){
      const levels = Array.isArray(cfg.levels) ? cfg.levels : [];
      currentLevel++;
      if (currentLevel > levels.length){
        running = false;
        stopSpawning();
        clearItems();
        try{ winSound.currentTime=0; winSound.play(); }catch(_){}
        showGameCompleteOverlay({
          score,
          hits,
          wrong: wrongClicks,
          missed: missedCorrect
        });
        return;
      }

      const game = document.getElementById('game');
      currentQuestion = levels[currentLevel - 1] || {};
      const correctArr = Array.isArray(currentQuestion.correct)
        ? currentQuestion.correct.filter(Boolean)
        : [];
      neededCorrect = correctArr.length;
      foundCorrect = new Set();

      setQuestionText(currentQuestion.target || currentQuestion.question || '');

      stopSpawning();
      clearItems();

      const correct = correctArr.map(v => ({ val: v, good: true }));
      const wrong   = (currentQuestion.wrong || []).map(v => ({ val: v, good: false }));
      const pool = [...correct, ...wrong];
      if (!pool.length) return;

      // "мешок" для анти-дубликатов
      let bag = shuffleCopy(pool);
      let bagIndex = 0;

      const gh  = game.clientHeight;
      const fps = 60;
      const fallDistPx  = gh + 320;
      const fallTimeSec = fallDistPx / (SPEED.vel * fps);

      // целевое число объектов одновременно, но жёсткий максимум 4
      const sNorm = clamp((Number(cfg?.speed ?? 5) - 1) / 9, 0, 1);
      const targetActive = Math.round(2 + sNorm * (5 - 2)); // мягче
      const maxActive    = 4;

      let interval = (fallTimeSec / targetActive) * 1000;
      interval = clamp(interval, 450, 2200);

      function nextFromBag(){
        if (bagIndex >= bag.length){
          bag = shuffleCopy(pool);
          bagIndex = 0;
        }
        return bag[bagIndex++];
      }

      function spawnNext(){
        if (!running) return;

        const activeNow = document.querySelectorAll('.item').length;
        if (activeNow >= maxActive){
          spawnerHandle = setTimeout(spawnNext, 140);
          return;
        }

        const obj = nextFromBag();
        drop(obj);

        const jitter = interval * (0.92 + Math.random() * 0.22);
        spawnerHandle = setTimeout(spawnNext, Math.max(200, jitter));
      }

      spawnNext();
    }

    /* ===== Элемент: создание/падение/клик ===== */
    function drop(obj){
      const game = document.getElementById('game');
      const STYLE = cfg.style || {};
      const FONT = cfg.font || 'Rubik';
      const FONT_SIZE = Number(cfg.fontSize || 24);
      const TEXT_COLOR = cfg.textColor || '#ffffff';

      const el = document.createElement('div');
      el.className =
        `item shape-${STYLE.shape || 'rounded'} `+
        `${STYLE.shadow?'fx-shadow':''} `+
        `${STYLE.fx3d?'fx-3d':''} `+
        `${STYLE.glow?'fx-glow':''} `+
        `${STYLE.borderOn && STYLE.borderWidth>0 ? 'fx-border' : ''}`;
      el.dataset.good = obj.good ? '1' : '0';
      el.dataset.value = obj.val;
      el.style.setProperty('--glow', STYLE.glowColor || '#00f0ff');

      const bg = document.createElement('div');
      bg.className = 'bg';
      const content = document.createElement('div');
      content.className = 'content';
      const PAD = Number(STYLE.pad || 22);
      content.style.padding = PAD + 'px';
      const IMG_BOX = Number(STYLE.imgBox || 160);
      el.appendChild(bg); el.appendChild(content);

      // фон‑держатели
      const bgCol = STYLE.bgColor || 'transparent';
      let bgList = [];

      if (STYLE.bgImage){
        bgList = bgList.concat(
          String(STYLE.bgImage)
            .split(/[\n\r,|;]+/)
            .map(s=>s.trim())
            .filter(Boolean)
        );
      }
      if (STYLE.bgImages){
        if (Array.isArray(STYLE.bgImages)){
          bgList = bgList.concat(STYLE.bgImages.filter(Boolean));
        } else {
          bgList = bgList.concat(
            String(STYLE.bgImages)
              .split(/[\n\r,|;]+/)
              .map(s=>s.trim())
              .filter(Boolean)
          );
        }
      }
      bgList = bgList.filter(Boolean);

      if (!bgList.length){
        bg.style.backgroundImage = 'none';
        bg.style.backgroundColor = bgCol;
      } else {
        const chosenBg = bgList[Math.floor(Math.random() * bgList.length)];
        bg.style.backgroundImage = `url(${chosenBg})`;
        bg.style.backgroundColor = 'transparent';
      }
      bg.style.opacity = String(clamp(Number(STYLE.opacity ?? 1), 0, 1));

      const shapeKind = (STYLE.shape || 'rounded');
      if (STYLE.borderOn && STYLE.borderWidth > 0){
        const bw = `${parseInt(STYLE.borderWidth,10)}px`;
        const bc = STYLE.borderColor || '#fff';
        if (shapeKind === 'diamond' || shapeKind === 'star'){
          bg.style.borderWidth = '0px';
          bg.classList.add('poly-border');
          bg.style.setProperty('--bw', bw);
          bg.style.setProperty('--bc', bc);
        } else {
          bg.classList.remove('poly-border');
          bg.style.removeProperty('--bw');
          bg.style.removeProperty('--bc');
          bg.style.borderColor = bc;
          bg.style.borderWidth = bw;
        }
      } else {
        bg.classList.remove('poly-border');
        bg.style.removeProperty('--bw');
        bg.style.removeProperty('--bc');
        bg.style.borderWidth = '0px';
      }

      // контент
      if (/^https?:\/\//i.test(obj.val)) {
        const img = document.createElement('img');
        img.src = obj.val;
        content.appendChild(img);
        content.style.setProperty('--cw', IMG_BOX + 'px');
        content.style.setProperty('--ch', IMG_BOX + 'px');
      } else if ((cfg.language||'') === 'math'){
        const span = document.createElement('span');
        span.textContent = `\\(${obj.val}\\)`;
        span.style.color = TEXT_COLOR;
        span.style.fontSize = `${FONT_SIZE}px`;
        span.style.fontFamily = `${FONT}, system-ui, sans-serif`;
        content.appendChild(span);
      } else {
        const span = document.createElement('span');
        span.textContent = String(obj.val);
        span.style.color = TEXT_COLOR;
        span.style.fontFamily = `${FONT}, system-ui, sans-serif`;
        span.style.fontSize = `${FONT_SIZE}px`;
        content.appendChild(span);
      }

      const DIR = (cfg.direction || 'down');
      const gw = game.clientWidth;
      const gh = game.clientHeight;

      // сначала добавляем, меряем, потом ставим x чтобы не было скучности справа
      game.appendChild(el);
      fitGeometryBox(el);
      autoFitText(el, FONT_SIZE, 12);

      if ((cfg.language||'') === 'math'){
        MathJax.typesetPromise([el]).then(()=>{
          fitGeometryBox(el);
          placeInitial();
        });
      } else {
        placeInitial();
      }

      let x, y;
      const vel = SPEED.vel;
      const swayAmp  = rnd(6, 22);
      const swayFreq = rnd(0.003, 0.008);
      let t = 0;
      let alive = true;

      function placeInitial(){
        const W = el.offsetWidth;
        const H = el.offsetHeight;
        const marginX = 20;
        const marginY = 16;

        if (DIR === 'down'){
          x = rnd(marginX, Math.max(marginX, gw - W - marginX));
          y = -H - 40;
        } else if (DIR === 'up'){
          x = rnd(marginX, Math.max(marginX, gw - W - marginX));
          y = gh + H + 40;
        } else if (DIR === 'left'){
          x = -W - 60;
          y = rnd(marginY, Math.max(marginY, gh - H - marginY));
        } else { // right
          x = gw + W + 60;
          y = rnd(marginY, Math.max(marginY, gh - H - marginY));
        }
        el.style.left = x + 'px';
        el.style.top  = y + 'px';
      }

      function step(){
        if(!alive) return;
        t += 1;

        if (DIR === 'down'){
          y += vel;
          const dx = Math.sin(t*swayFreq) * swayAmp;
          el.style.top = y+'px';
          el.style.transform = `translateX(${dx}px)`;
          if (y > gh + 260){
            alive = false;
            if (el.dataset.good === '1') missedCorrect++;
            el.remove(); return;
          }
        } else if (DIR === 'up'){
          y -= vel;
          const dx = Math.sin(t*swayFreq) * swayAmp;
          el.style.top = y+'px';
          el.style.transform = `translateX(${dx}px)`;
          if (y < -260){
            alive = false;
            if (el.dataset.good === '1') missedCorrect++;
            el.remove(); return;
          }
        } else if (DIR === 'left'){
          x += vel;
          const dy = Math.sin(t*swayFreq) * swayAmp;
          el.style.left = x+'px';
          el.style.transform = `translateY(${dy}px)`;
          if (x > gw + 260){
            alive = false;
            if (el.dataset.good === '1') missedCorrect++;
            el.remove(); return;
          }
        } else { // right
          x -= vel;
          const dy = Math.sin(t*swayFreq) * swayAmp;
          el.style.left = x+'px';
          el.style.transform = `translateY(${dy}px)`;
          if (x < -260){
            alive = false;
            if (el.dataset.good === '1') missedCorrect++;
            el.remove(); return;
          }
        }
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);

      el.addEventListener('click', (ev)=>{
        if (!running) return;
        if (!alive) return;
        ev.stopPropagation();

        const isGood = el.dataset.good === '1';
        if (isGood){
          alive = false;
          hits++;
          streak++;
          const bonus = Math.max(0, streak-1) * 2;
          const pts = SPEED.basePts + bonus;
          score += pts;
          hudScore.textContent = String(score);

          foundCorrect.add(el.dataset.value);

          el.classList.add('caught');
          playPop(el);
          popScore(el, '+'+pts, true);
          fireworksAtElement(el);

          setTimeout(()=> el.remove(), 520);

          if (foundCorrect.size >= neededCorrect){
            stopSpawning();
            clearItems();
            const totalLevels = (cfg.levels || []).length;
            if (currentLevel >= totalLevels){
              try{ winSound.currentTime=0; winSound.play().catch(()=>{}); }catch(_){}
              showGameCompleteOverlay({
                score,
                hits,
                wrong: wrongClicks,
                missed: missedCorrect
              });
            } else {
              // дадим анимации доиграть
              setTimeout(()=>{ startLevel(); }, 1100);
            }
          }
        } else {
          wrongClicks++;
          streak = 0;
          if (score > 0){
            score = Math.max(0, score - WRONG_PENALTY);
            hudScore.textContent = String(score);
          }
          try{
            wrongSound.currentTime=0;
            wrongSound.play().catch(()=>{});
          }catch(_){}
          el.classList.add('tint-red','shake');
          popScore(el, '−'+WRONG_PENALTY, false);
          setTimeout(()=> el.classList.remove('tint-red','shake'), 420);
        }
      });
    }

    /* ===== Геометрия / автофит ===== */
    function fitGeometryBox(el){
      const STYLE = cfg.style || {};
      const content = el.querySelector('.content');
      if (content && content.style.getPropertyValue('--cw')) return;

      const shape = STYLE.shape || 'rounded';
      el.style.width = ''; el.style.height='';
      const r = content.getBoundingClientRect();

      const hasImageFrame =
        (Array.isArray(STYLE.bgImage) ? STYLE.bgImage.length > 0 : !!String(STYLE.bgImage||'').trim()) ||
        (Array.isArray(STYLE.bgImages) ? STYLE.bgImages.length > 0 : false);

      const padX = hasImageFrame ? 30 : 22;
      const padY = hasImageFrame ? 24 : 18;

      let W = Math.ceil(r.width + padX*2);
      let H = Math.ceil(r.height + padY*2);

      if (shape === 'circle' || shape === 'diamond' || shape === 'star'){
        const S = Math.max(W, H);
        W = H = Math.ceil(S + 16);
      }
      el.style.width = W + 'px';
      el.style.height = H + 'px';
    }

    function autoFitText(el, startPx, minPx){
      const span = el.querySelector('.content span');
      if(!span) return;
      let fs = startPx;
      const STYLE = cfg.style || {};
      const pad = STYLE.pad ?? 18;
      const maxW = el.clientWidth - pad*2;
      const maxH = el.clientHeight - pad*2;
      const fits = ()=> {
        const rr = span.getBoundingClientRect();
        return (rr.width <= maxW && rr.height <= maxH);
      };
      while (fs > minPx){
        span.style.fontSize = fs + 'px';
        if (fits()) break;
        fs -= 1;
      }
    }

    /* ===== Эффекты ===== */
    function playPop(el){
      try{
        popSound.currentTime = 0;
        popSound.play().catch(()=>{});
      }catch(_){}
      const r = el.getBoundingClientRect();
      for(let i=0;i<16;i++){
        const s = document.createElement('div');
        s.className = 'sparkle';
        s.style.left = (r.left + r.width/2) + 'px';
        s.style.top  = (r.top  + r.height/2) + 'px';
        const angle = Math.random() * Math.PI * 2;
        const dist = 50 + Math.random()*80;
        s.style.setProperty('--dx', (Math.cos(angle)*dist) + 'px');
        s.style.setProperty('--dy', (Math.sin(angle)*dist) + 'px');
        document.body.appendChild(s);
        setTimeout(()=> s.remove(), 1000);
      }
    }

    function popScore(el, text, positive){
      const r = el.getBoundingClientRect();
      const node = document.createElement('div');
      node.className = 'score-float';
      node.style.left = (r.left + r.width/2) + 'px';
      node.style.top  = (r.top + 6) + 'px';
      node.style.color = positive ? 'var(--ui)' : '#ff4d6a';
      node.textContent = text;
      document.body.appendChild(node);
      setTimeout(()=> node.remove(), 950);
    }

    function burstAt(x,y,parts=18,base=70){
      for(let i=0;i<parts;i++){
        const p = document.createElement('div');
        p.className='firework';
        p.style.left = x+'px';
        p.style.top  = y+'px';
        const angle = (Math.PI*2) * (i/parts) + Math.random()*0.25;
        const dist = base + Math.random()*base;
        p.style.setProperty('--tx', (Math.cos(angle)*dist)+'px');
        p.style.setProperty('--ty', (Math.sin(angle)*dist)+'px');
        // более "призменные" оттенки — холодные + немного тёплых
        const hue = Math.random() < 0.6
          ? 190 + Math.random()*100
          : 40 + Math.random()*40;
        p.style.background = `hsl(${Math.floor(hue)},90%,70%)`;
        document.body.appendChild(p);
        setTimeout(()=> p.remove(), 900);
      }
    }

    function fireworksAtElement(el){
      const r = el.getBoundingClientRect();
      const cx = r.left + r.width/2;
      const cy = r.top + r.height/2;
      burstAt(cx, cy, 18, 60);
    }

    function fireworks(count=4){
      const W = window.innerWidth, H = window.innerHeight;
      for(let k=0;k<count;k++){
        const x = Math.random()*W*0.7 + W*0.15;
        const y = Math.random()*H*0.4 + H*0.15;
        burstAt(x,y,28,90);
      }
    }
  </script>
</body>
</html>
