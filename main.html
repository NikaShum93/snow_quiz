<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Falling Items — Game</title>
  <style>
    :root{
      --ui:#ffd700;
      --ui-soft:rgba(255,215,0,.18);
      --glow:#70e0ff;
    }
    html,body{height:100%}
    body{
      margin:0;
      background:transparent;
      color:#fff;
      overflow:hidden;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    #game{
      position:relative;
      width:100%;
      height:100%;
      overflow:hidden;
    }
    /* ===== HUD ===== */
    .hud{
      position:fixed;
      left:12px; top:12px; right:12px;
      display:flex;
      gap:12px;
      align-items:flex-start; /* вопрос сверху по центру */
      justify-content:space-between;
      font-weight:700;
      z-index:10;
      pointer-events:none;
    }
    .hud-left{
      display:flex;
      gap:8px;
      align-items:center;
      /* фиксированная ширина слева, чтобы вопрос НЕ съезжал,
         даже если таймера нет */
      min-width:96px;
    }
    /* glass‑prism стиль для ВСЕХ рамок */
    .badge,
    .overlay .panel,
    .final-inner{
      pointer-events:auto;
      background:linear-gradient(135deg, rgba(255,255,255,.08), rgba(15,15,35,.9));
      border:1px solid rgba(255,255,255,.28);
      border-radius:18px;
      padding:10px 16px;
      box-shadow:
        0 18px 45px rgba(0,0,0,.7),
        0 0 0 1px rgba(255,255,255,.04);
      backdrop-filter:blur(18px) saturate(140%);
    }
    .badge{
      pointer-events:none;
      font-size:16px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-height:38px;
    }
    .timer{min-width:96px; text-align:center}
    .score{min-width:96px; text-align:center}
    .hud-center{
      flex:1;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      max-width:70%;
      pointer-events:none;
    }
    .questionBadge{
      position:relative;
      max-width:100%;
      padding:14px 20px;
      opacity:0;
      transform:translateY(-10px);
      transition:opacity .18s ease, transform .18s ease;
    }
    body.has-question .questionBadge{
      opacity:1;
      transform:translateY(0);
    }
    .questionBadge .hudQuestion{
      font-weight:500;
      line-height:1.25;
      max-width:100%;
      white-space:normal;
      word-wrap:break-word;
      max-height:4.4em;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    /* ===== Оверлеи (старт / финал) ===== */
    .overlay{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center; flex-direction:column;
      background:radial-gradient(circle at top, rgba(80,120,255,.22), transparent 55%);
      color:#fff; z-index:20; gap:18px;
      pointer-events:auto;
    }
    .overlay .panel{
      min-width:min(92vw,540px);
      text-align:center;
      padding:22px 26px;
    }
    .overlay h2{
      margin:4px 0 10px;
      font-size:24px; font-weight:900; color:var(--ui);
      text-shadow:0 0 20px var(--ui-soft);
    }
    .overlay p{ margin:0 0 8px; opacity:.9 }
    .overlay .row{ display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap }
    .overlay button{
      background:linear-gradient(135deg,#ffe08a,#ffd700);
      color:#000; border:0; border-radius:999px; font-weight:900; padding:12px 20px; cursor:pointer;
      transition:transform .12s ease, box-shadow .12s ease;
      pointer-events:auto;
      box-shadow:0 12px 32px rgba(0,0,0,.6);
    }
    .overlay button:hover{
      transform:translateY(-1px);
      box-shadow:0 16px 40px rgba(0,0,0,.75);
    }
    /* ===== Падающие элементы / random ===== */
    .item{
      position:absolute;
      top:-160px; left:0;
      transform:translateZ(0);
      will-change:transform, top, left, width, height;
      display:inline-flex;
      align-items:center; justify-content:center;
      min-width:120px; min-height:80px;
      padding:0;
      user-select:none; cursor:pointer;
      transition:transform .12s ease; /* для лёгкого scale в random */
    }
    .item .bg{
      position:absolute; inset:0;
      background:transparent;
      opacity:1;
      border:0 solid #fff;
      box-shadow:none;
      background-position:center !important;
      background-repeat:no-repeat !important;
      background-size:contain !important;
    }
    .item .content{
      position:relative; z-index:1;
      display:flex; align-items:center; justify-content:center;
      text-align:center; line-height:1.15;
      width:var(--cw, auto);
      height:var(--ch, auto);
    }
    .item .content span{
      display:inline-block;
      font-weight:800;
      white-space:nowrap;
    }
    .item .content .mjx-container{ font-size:inherit !important; }
    .item .content img{
      display:block;
      width:100%;
      height:100%;
      max-width:none;
      max-height:none;
      object-fit:contain;
      pointer-events:none;
    }
    .shape-rect    .bg{ border-radius:10px }
    .shape-rounded .bg{ border-radius:20px }
    .shape-circle  .bg{ border-radius:50% }
    .shape-diamond .bg{ clip-path:polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%) }
    .shape-star    .bg{
      clip-path: polygon(
        50% 0%, 61% 35%, 98% 35%,
        68% 57%, 79% 91%, 50% 70%,
        21% 91%, 32% 57%, 2% 35%, 39% 35%
      );
    }
    .poly-border { box-shadow: inset 0 0 0 var(--bw, 1px) var(--bc, #fff); }
    .shape-diamond.fx-shadow .bg,
    .shape-star.fx-shadow .bg{
      filter:drop-shadow(0 10px 18px rgba(0,0,0,.55));
      box-shadow:none;
    }
    .shape-diamond.fx-glow .bg,
    .shape-star.fx-glow .bg{
      filter:drop-shadow(0 0 12px var(--glow, #00f0ff));
    }
    .shape-diamond.fx-3d .bg,
    .shape-star.fx-3d .bg{
      filter:drop-shadow(7px 7px 16px rgba(0,0,0,.55));
    }
    .fx-shadow .bg{ box-shadow:0 10px 30px rgba(0,0,0,.55) }
    .fx-3d     .bg{ box-shadow:7px 7px 20px rgba(0,0,0,.55), inset -5px -5px 12px rgba(255,255,255,.22) }
    .fx-glow   .bg{ box-shadow:0 0 18px var(--glow, #00f0ff), 0 0 28px rgba(0,0,0,.25) }
    .fx-border .bg{ border-style:solid }
    /* Поп при ловле — СИЛЬНЕЕ */
    .caught{
      animation:caughtBoom .6s cubic-bezier(.2,1.2,.4,1) forwards;
    }
    @keyframes caughtBoom{
      0%   { transform:scale(1);   opacity:1 }
      35%  { transform:scale(1.55); opacity:1 }
      100% { transform:scale(0.15); opacity:0 }
    }
    /* Блёстки */
    .sparkle{
      position:absolute; width:6px; height:6px; border-radius:50%;
      background:rgba(255,255,255,.9); pointer-events:none;
      animation:spark 0.9s forwards;
      filter:drop-shadow(0 0 6px #fff); z-index:5;
    }
    @keyframes spark{
      from{ opacity:1; transform:translate(0,0) scale(1) }
      to  { opacity:0; transform:translate(var(--dx), var(--dy)) scale(.2) }
    }
    /* Всплывающие очки */
    .score-float{
      position:fixed; z-index:30;
      font-weight:900;
      text-shadow:0 0 10px rgba(255,255,255,.5), 0 0 20px var(--ui-soft);
      animation:floatUp .85s ease-out forwards;
      pointer-events:none;
    }
    @keyframes floatUp{
      0%  { transform:translate(-50%,-10px); opacity:0 }
      10% { opacity:1; }
      100%{ transform:translate(-50%,-60px); opacity:0 }
    }
    /* Фейерверк (в конце и мини-версии по клику) */
    .firework{
      position:fixed; width:4px; height:4px; border-radius:50%;
      background:#fff; pointer-events:none; z-index:40; animation:fw 900ms ease-out forwards;
    }
    @keyframes fw{
      from{ transform:translate(0,0) scale(1); opacity:1 }
      to  { transform:translate(var(--tx), var(--ty)) scale(0.1); opacity:0 }
    }
    /* Красный тинт при ошибке */
    .tint-red .bg { animation:redTintOnly 550ms ease; }
    @keyframes redTintOnly {
      0%   { filter:none; }
      15%  { filter:hue-rotate(-25deg) saturate(3) brightness(1.2) contrast(1.2); }
      50%  { filter:hue-rotate(-10deg) saturate(2.5) brightness(1.1) contrast(1.1); }
      100% { filter:none; }
    }
    /* Тряска при ошибке */
    .shake{
      animation:shake .38s ease;
    }
    @keyframes shake{
      0%{transform:translateX(0)}
      20%{transform:translateX(-6px)}
      40%{transform:translateX(6px)}
      60%{transform:translateX(-4px)}
      80%{transform:translateX(4px)}
      100%{transform:translateX(0)}
    }
    /* Финальное окно (тот же glass‑prism стиль) */
    .final-card{
      position:relative;
      padding:4px;
      border-radius:22px;
      overflow:hidden;
      animation:finalFadeIn .45s ease-out both;
    }
    .final-inner{
      position:relative;
      border-radius:18px;
      min-width:min(92vw,360px);
      color:#fff;
      text-align:center;
      padding:22px 26px;
    }
    .final-title{
      font-size:24px;
      margin:0 0 10px;
      color:var(--ui);
      text-shadow:0 0 18px var(--ui-soft);
    }
    .final-main-score{
      font-size:32px;
      font-weight:800;
      margin-bottom:12px;
      text-shadow:0 0 18px rgba(255,255,255,.5);
    }
    .final-stats{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:6px 14px;
      text-align:left;
      font-size:15px;
      margin-bottom:18px;
    }
    .final-stats .label{opacity:.85}
    .final-stats .value{font-weight:700}
    .btn-final{
      background:linear-gradient(135deg,#ffe08a,#ffd700);
      color:#000;
      border:0;
      border-radius:999px;
      font-weight:900;
      padding:10px 20px;
      cursor:pointer;
      font-size:16px;
      box-shadow:0 8px 26px rgba(0,0,0,.45);
      transition:transform .12s ease, box-shadow .12s ease;
    }
    .btn-final:hover{
      transform:translateY(-1px);
      box-shadow:0 10px 30px rgba(0,0,0,.6);
    }
    @keyframes finalFadeIn{
      from{ opacity:0; transform:translateY(10px) scale(.96);}
      to  { opacity:1; transform:translateY(0) scale(1);}
    }
    .hidden{display:none !important;}
  </style>
  <script>
    function loadGoogleFont(fontName){
      if(!fontName) return;
      const family = fontName.replace(/ /g, '+');
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = `https://fonts.googleapis.com/css2?family=${family}:wght@400;700&display=swap`;
      document.head.appendChild(link);
    }
  </script>
</head>
<body>
  <!-- HUD -->
  <div class="hud">
    <div class="hud-left">
      <div class="badge timer hidden" id="hudTimer">00:00</div>
    </div>
    <div class="hud-center">
      <div class="badge questionBadge">
        <div class="hudQuestion" id="hudQuestion"></div>
      </div>
    </div>
    <div class="badge score" id="hudScore">0</div>
  </div>
  <!-- Сцена -->
  <div id="game" aria-live="polite"></div>
  <!-- MathJax -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <script>
    /* ===== Локализация ===== */
    const I18N = {
      ru:{
        startTitle:"Игра «Падающие элементы»",
        startBtn:"Начать",
        restartBtn:"Играть снова",
        time:"Время", score:"Счёт",
        gameComplete:"Игра пройдена!",
        hits:"Попаданий", wrong:"Ошибок", missed:"Пропущено правильных",
        finalFeedbackTitle:"Молодец!", defaultFinalFeedback:"Отличная работа!",
        startHint:"Нажмите, чтобы начать игру."
      },
      math:{
        startTitle:"Игра «Падающие элементы» (Математика)",
        startBtn:"Начать",
        restartBtn:"Играть снова",
        time:"Время", score:"Счёт",
        gameComplete:"Игра пройдена!",
        hits:"Попаданий", wrong:"Ошибок", missed:"Пропущено правильных",
        finalFeedbackTitle:"Молодец!", defaultFinalFeedback:"Отличная работа!",
        startHint:"Нажмите, чтобы начать игру."
      },
      en:{
        startTitle:"Falling Items Game",
        startBtn:"Start",
        restartBtn:"Play again",
        time:"Time", score:"Score",
        gameComplete:"Game completed!",
        hits:"Hits", wrong:"Mistakes", missed:"Missed correct",
        finalFeedbackTitle:"Well done!", defaultFinalFeedback:"Great job!",
        startHint:"Click to start the game."
      }
    };
    function t(lang,key,...args){
      const dict = I18N[lang]||I18N.ru; const v = dict[key];
      return (typeof v==="function")?v(...args):(v??key);
    }
    const $  = sel => document.querySelector(sel);
    const rnd = (a,b)=> a + Math.random()*(b-a);
    const clamp = (v,min,max)=> Math.max(min, Math.min(max,v));
    function hexToRgb(hex){
      let s = (hex||'').trim();
      if(!s) return {r:255,g:215,b:0};
      if(s[0]==='#') s=s.slice(1);
      if(s.length===3) s=s.split('').map(c=>c+c).join('');
      const n=parseInt(s,16);
      return {r:(n>>16)&255, g:(n>>8)&255, b:(n)&255};
    }
    const params = new URLSearchParams(location.search);
    const GAME_ID = params.get('id');
    const JSON_BASE = "https://nikashum93.github.io/texts/data/";
    let cfg = null;
    let LANG = 'ru';
    /* ===== HUD refs ===== */
    const hudTimer    = $('#hudTimer');
    const hudScore    = $('#hudScore');
    const hudQuestion = $('#hudQuestion');

    // до старта игры не показываем рамку счётчика
    if (hudScore) {
      hudScore.classList.add('hidden');
    }

    /* ===== Звук ===== */
    const popSound   = new Audio("pop.mp3");
    const wrongSound = new Audio("wrong.mp3");
    const winSound   = new Audio("win.mp3");
    /* ===== Глобальные статы ===== */
    let score = 0;
    let currentLevel = 0;
    let running = false;
    let globalTimerHandle = null;
    let globalTimeLeft = 0;
    let spawnerHandle = null;   // interval id
    let hits = 0;
    let wrongClicks = 0;
    let missedCorrect = 0;
    let streak = 0;
    let currentQuestion = null;
    let neededCorrect = 0;
    let foundCorrect = new Set();
    let SPEED = { vel: 1.5, spawn: 1000, basePts: 20 };
    /* ===== ФОНЫ ===== */
    let bgImgEl = null;

    (async function boot(){
      if(!GAME_ID){
        showFatal("No id", "Не передан id в строке запроса.");
        return;
      }
      try{
        const url = `${JSON_BASE}${encodeURIComponent(GAME_ID)}.json?v=${Date.now()}`;
        const res = await fetch(url, { cache:'no-store' });
        if(!res.ok) throw new Error('HTTP '+res.status);
        cfg = await res.json();
      }catch(e){
        showFatal("Load error", `Ошибка загрузки настроек: ${e.message}\nПроверь публикацию в texts/data.`);
        return;
      }
      LANG = (cfg.language || 'ru').toLowerCase();
      if (!I18N[LANG] && LANG!=='math') LANG = 'ru';
      if(cfg.font)         loadGoogleFont(cfg.font);
      if(cfg.questionFont) loadGoogleFont(cfg.questionFont);
      const uiColor = (cfg.style && (cfg.style.borderColor || cfg.style.glowColor)) || '#ffd700';
      const rgb = Object.values(hexToRgb(uiColor)).join(',');
      document.documentElement.style.setProperty('--ui', uiColor);
      document.documentElement.style.setProperty('--ui-soft', 'rgba('+rgb+',.18)');
      if (cfg.style && cfg.style.glowColor){
        document.documentElement.style.setProperty('--glow', cfg.style.glowColor);
      }
      if (cfg.cursor) document.body.style.cursor = `url(${cfg.cursor}), auto`;

      // если в конфиге нет таймера — пузырь таймера вообще не нужен
      const gTime = Number(cfg?.globalTimer || 0);
      if (!gTime && hudTimer){
        hudTimer.parentNode && hudTimer.parentNode.removeChild(hudTimer);
      }

      setupBackgrounds();
      showStartOverlay();
    })();

    function setupBackgrounds(){
      const list = Array.isArray(cfg?.backgrounds) ? cfg.backgrounds.filter(Boolean) : [];
      if (!list.length){
        if (bgImgEl){ bgImgEl.remove(); bgImgEl = null; }
        return;
      }
      if (!bgImgEl){
        bgImgEl = document.createElement('img');
        Object.assign(bgImgEl.style, {
          position:'fixed', inset:'0', width:'100%', height:'100%',
          objectFit:'cover', zIndex:'-1', pointerEvents:'none'
        });
        document.body.prepend(bgImgEl);
      }
      const pick = () => list[Math.floor(Math.random()*list.length)];
      bgImgEl.src = pick();
      const _startLevel = startLevel;
      startLevel = function(){
        if (bgImgEl && bgImgEl.parentNode){
          const fresh = bgImgEl.cloneNode(false);
          fresh.src = pick();
          bgImgEl.parentNode.replaceChild(fresh, bgImgEl);
          bgImgEl = fresh;
        }
        _startLevel();
      };
    }
    /* ===== HUD / Оверлеи ===== */
    let overlayNode = null;
    function setQuestionText(text){
      const q = (text || '').trim();
      if (!hudQuestion) return;
      const lang = (cfg.language || 'ru').toLowerCase();
      const isMath = (lang === 'math');
      const qFont = cfg.questionFont || cfg.font || 'Rubik';
      const baseSize = Number(cfg.questionFontSize || 26);
      if (q){
        document.body.classList.add('has-question');
      } else {
        document.body.classList.remove('has-question');
      }
      if (isMath && q){
        hudQuestion.textContent = `\\(${q}\\)`;
        MathJax.typesetPromise([hudQuestion]);
      } else {
        hudQuestion.textContent = q;
      }
      const len = q.length;
      let size = baseSize;
      if (!cfg.questionFontSize){
        if (len > 110) size = 18;
        else if (len > 60) size = 22;
      }
      hudQuestion.style.fontSize   = size + 'px';
      hudQuestion.style.fontFamily = `${qFont}, system-ui, sans-serif`;
    }
    function showFatal(title, message){
      const ov = document.createElement('div');
      ov.className = 'overlay';
      ov.innerHTML = `
        <div class="panel">
          <h2>${title}</h2>
          <p style="white-space:pre-wrap">${message}</p>
        </div>`;
      document.body.appendChild(ov);
    }
    function showStartOverlay(){
      if (overlayNode) overlayNode.remove();
      overlayNode = document.createElement('div');
      overlayNode.className = 'overlay';
      const title  = (cfg.start && typeof cfg.start.title === 'string' && cfg.start.title.trim())
                     ? cfg.start.title.trim()
                     : t(LANG,'startTitle');
      const btnTxt = (cfg.start && typeof cfg.start.btnText === 'string' && cfg.start.btnText.trim())
                     ? cfg.start.btnText.trim()
                     : t(LANG,'startBtn');
      const hint   = t(LANG,'startHint');
      overlayNode.innerHTML = `
        <div class="panel">
          <h2>${title}</h2>
          <p style="opacity:.8; font-size:15px; margin-top:4px">
            ${hint}
          </p>
          <div class="row" style="margin-top:14px">
            <button id="btnStart">${btnTxt}</button>
          </div>
        </div>`;
      document.body.appendChild(overlayNode);
      $('#btnStart').addEventListener('click', ()=>{
        overlayNode.remove();
        startGame();
      }, { once: true });
    }
    function showGameCompleteOverlay(stats){
      if (overlayNode) overlayNode.remove();
      overlayNode = document.createElement('div');
      overlayNode.className = 'overlay';
      const custom  = (cfg.finalFeedback || cfg.feedback || "").trim();
      const fbTitle = t(LANG,'finalFeedbackTitle');
      const fbText  = t(LANG,'defaultFinalFeedback');
      const sc = (stats && stats.score != null) ? stats.score : score;
      const h  = stats?.hits ?? hits;
      const w  = stats?.wrong ?? wrongClicks;
      const m  = stats?.missed ?? missedCorrect;
      overlayNode.innerHTML = `
        <div class="final-card">
          <div class="final-inner">
            <h2 class="final-title">${t(LANG,'gameComplete')}</h2>
            ${
              custom
                ? `<p style="white-space:pre-wrap; margin:0 0 10px">${custom}</p>`
                : `<p style="margin:6px 0 10px; font-size:18px; color:var(--ui)">${fbTitle}</p>
                   <p style="white-space:pre-wrap; margin:0 0 4px">${fbText}</p>`
            }
            <div class="final-main-score">${sc}</div>
            <div class="final-stats">
              <div><span class="label">${t(LANG,'hits')}:</span> <span class="value">${h}</span></div>
              <div><span class="label">${t(LANG,'wrong')}:</span> <span class="value">${w}</span></div>
              <div><span class="label">${t(LANG,'missed')}:</span> <span class="value">${m}</span></div>
            </div>
            <button id="btnRestart" class="btn-final">${t(LANG,'restartBtn')}</button>
          </div>
        </div>`;
      document.body.appendChild(overlayNode);
      $('#btnRestart').addEventListener('click', ()=> location.reload(), { once:true });
    }
    /* ===== Геймплей ===== */
    function computeSpeedParams(S){
      const s = clamp(Number(S||5), 1, 10);
      const vel = 0.65 + (s-1) * (6.2-0.65)/9;
      const spawn = 1700 - (s-1) * (1350)/9;
      const basePts = 8 + (s-1) * (50-8)/9;
      return { vel, spawn, basePts: Math.round(basePts) };
    }
    function shuffleCopy(arr){
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
    function startGame(){
      SPEED = computeSpeedParams(cfg?.speed ?? 5);

      // как только игра реально стартует — показываем счётчик
      if (hudScore) {
        hudScore.classList.remove('hidden');
      }

      score = 0;
      hits = 0;
      wrongClicks = 0;
      missedCorrect = 0;
      streak = 0;
      hudScore.textContent = '0';

      // таймер
      if (globalTimerHandle){
        clearInterval(globalTimerHandle);
        globalTimerHandle = null;
      }
      globalTimeLeft = Number(cfg?.globalTimer || 0);
      if (globalTimeLeft > 0 && hudTimer){
        hudTimer.classList.remove('hidden');
        hudTimer.textContent = formatTime(globalTimeLeft);
        globalTimerHandle = setInterval(()=>{
          if (!running) return;
          globalTimeLeft--;
          hudTimer.textContent = formatTime(globalTimeLeft);
          if (globalTimeLeft <= 0){
            clearInterval(globalTimerHandle);
            globalTimerHandle = null;
            running = false;
            stopSpawning();
            clearItems();
            fireworks();
            try{ winSound.currentTime=0; winSound.play(); }catch(_){}
            showGameCompleteOverlay({
              score,
              hits,
              wrong: wrongClicks,
              missed: missedCorrect
            });
          }
        }, 1000);
      } else if (hudTimer){
        hudTimer.classList.add('hidden');
        hudTimer.textContent = '';
      }

      if (cfg.randomLevels && Array.isArray(cfg.levels)) {
        cfg.levels = shuffleCopy(cfg.levels);
      }
      currentLevel = 0;
      running = true;
      startLevel();
    }
    function formatTime(sec){
      const m = Math.floor(sec / 60).toString().padStart(2,'0');
      const s = (sec % 60).toString().padStart(2,'0');
      return `${m}:${s}`;
    }
    function stopSpawning(){
      if (spawnerHandle){
        clearInterval(spawnerHandle);
        spawnerHandle = null;
      }
    }
    function clearItems(){
      document.querySelectorAll('.item').forEach(n => n.remove());
    }
    function startLevel(){
      const levels = Array.isArray(cfg.levels) ? cfg.levels : [];
      currentLevel++;
      if (currentLevel > levels.length){
        running = false;
        stopSpawning();
        clearItems();
        fireworks();
        try{ winSound.currentTime=0; winSound.play(); }catch(_){}
        showGameCompleteOverlay({
          score,
          hits,
          wrong: wrongClicks,
          missed: missedCorrect
        });
        return;
      }
      const game = document.getElementById('game');
      currentQuestion = levels[currentLevel - 1] || {};
      const correctArr = Array.isArray(currentQuestion.correct)
        ? currentQuestion.correct.filter(Boolean)
        : [];
      neededCorrect = correctArr.length;
      foundCorrect = new Set();
      setQuestionText(currentQuestion.target || currentQuestion.question || '');
      stopSpawning();
      clearItems();
      const correct = correctArr.map(v => ({ val: v, good: true }));
      const wrong   = (currentQuestion.wrong || []).map(v => ({ val: v, good: false }));
      const pool = [...correct, ...wrong];
      if (!pool.length) return;
      const gh  = game.clientHeight || 600;
      const fps = 60;
      const fallDistPx  = gh + 320;
      const fallTimeSec = fallDistPx / (SPEED.vel * fps);
      const sNorm = clamp((Number(cfg?.speed ?? 5) - 1) / 9, 0, 1);
      const DIR = (cfg.direction || 'down');
      const targetActive = (DIR === 'random')
        ? 6 + Math.round(sNorm * 3)   // random: 6–9
        : 3 + Math.round(sNorm * 3);  // обычный: 3–6
      const maxActive    = (DIR === 'random') ? 8 : 4;
      let interval = (fallTimeSec / targetActive) * 1000;
      interval = clamp(interval, 420, 2000);
      let lastSpawnValue = null;
      let lastLane = -1;
      const uniqueValues = [...new Set(pool.map(p => p.val))];
      const allowDupOnScreen = uniqueValues.length === 1;
      function countOnScreen(val){
        let n = 0;
        document.querySelectorAll('.item').forEach(el=>{
          if (el.dataset.value === val) n++;
        });
        return n;
      }
     const isRandomDir = (cfg.direction === 'random');

  let chosen = null;
  let tries = 0;
  while (tries < 30) {
    const cand = pool[Math.floor(Math.random() * poolLen)];
    const val  = cand.val;
    const sameOnScreen = countOnScreen(val);

    // не спавним подряд одно и то же
    if (poolLen > 1 && val === lastSpawnValue) {
      tries++; 
      continue;
    }
    // в режиме random запрещаем дубликаты на экране
    if (isRandomDir && !allowDupOnScreen && sameOnScreen >= 1) {
      tries++;
      continue;
    }
    // в обычных режимах – старое поведение
    if (!isRandomDir && !allowDupOnScreen && sameOnScreen >= 1) {
      tries++;
      continue;
    }

    chosen = cand;
    break;
  }

  if (!chosen) {
    // В режиме RANDOM, если подходящего без дублей не нашли — просто пропускаем этот тик
    if (isRandomDir && !allowDupOnScreen) {
      return;
    }
    // В остальных режимах оставляем старый запасной вариант
    chosen = pool[Math.floor(Math.random() * poolLen)];
  }

  lastSpawnValue = chosen.val;

        const gameW = game.clientWidth || 800;
        if (DIR === 'random'){
          // координаты в random считаются внутри drop
          drop(chosen, null);
        } else {
          const laneCount = clamp(Math.floor(gameW / 260), 3, 6);
          const laneWidth = gameW / laneCount;
          let lane = Math.floor(Math.random()*laneCount);
          if (laneCount > 1 && lane === lastLane){
            lane = (lane + 1 + Math.floor(Math.random() * (laneCount - 1))) % laneCount;
          }
          lastLane = lane;
          const xMin = lane * laneWidth + 18;
          const xMax = (lane+1)*laneWidth - 18;
          const spawnX = rnd(xMin, xMax);
          drop(chosen, spawnX);
        }
      }
      spawnerHandle = setInterval(spawnTick, interval);
    }
    /* ===== Элемент: создание / падение / клик ===== */
    function drop(obj, forcedX){
      const game = document.getElementById('game');
      const STYLE = cfg.style || {};
      const FONT = cfg.font || 'Rubik';
      const FONT_SIZE = Number(cfg.fontSize || 24);
      const TEXT_COLOR = cfg.textColor || '#ffffff';
      const el = document.createElement('div');
      el.className =
        `item shape-${STYLE.shape || 'rounded'} `+
        `${STYLE.shadow?'fx-shadow':''} `+
        `${STYLE.fx3d?'fx-3d':''} `+
        `${STYLE.glow?'fx-glow':''} `+
        `${STYLE.borderOn && STYLE.borderWidth>0 ? 'fx-border' : ''}`;
      el.dataset.good  = obj.good ? '1' : '0';
      el.dataset.value = obj.val;
      el.style.setProperty('--glow', STYLE.glowColor || '#00f0ff');
      const bg = document.createElement('div');
      bg.className = 'bg';
      const content = document.createElement('div');
      content.className = 'content';
      const PAD = Number(STYLE.pad || 22);
      content.style.padding = PAD + 'px';
      const IMG_BOX = Number(STYLE.imgBox || 160);
      el.appendChild(bg); el.appendChild(content);
      // фон
      const bgCol = STYLE.bgColor || 'transparent';
      let bgList = [];
      if (STYLE.bgImage){
        bgList = bgList.concat(
          String(STYLE.bgImage)
            .split(/[\n\r,|;]+/)
            .map(s=>s.trim())
            .filter(Boolean)
        );
      }
      if (STYLE.bgImages){
        if (Array.isArray(STYLE.bgImages)){
          bgList = bgList.concat(STYLE.bgImages.filter(Boolean));
        } else {
          bgList = bgList.concat(
            String(STYLE.bgImages)
              .split(/[\n\r,|;]+/)
              .map(s=>s.trim())
              .filter(Boolean)
          );
        }
      }
      bgList = bgList.filter(Boolean);
      if (!bgList.length){
        bg.style.backgroundImage = 'none';
        bg.style.backgroundColor = bgCol;
      } else {
        const chosenBg = bgList[Math.floor(Math.random() * bgList.length)];
        bg.style.backgroundImage = `url(${chosenBg})`;
        bg.style.backgroundColor = 'transparent';
      }
      bg.style.opacity = String(clamp(Number(STYLE.opacity ?? 1), 0, 1));
      const shapeKind = (STYLE.shape || 'rounded');
      if (STYLE.borderOn && STYLE.borderWidth > 0){
        const bw = `${parseInt(STYLE.borderWidth,10)}px`;
        const bc = STYLE.borderColor || '#fff';
        if (shapeKind === 'diamond' || shapeKind === 'star'){
          bg.style.borderWidth = '0px';
          bg.classList.add('poly-border');
          bg.style.setProperty('--bw', bw);
          bg.style.setProperty('--bc', bc);
        } else {
          bg.classList.remove('poly-border');
          bg.style.removeProperty('--bw');
          bg.style.removeProperty('--bc');
          bg.style.borderColor = bc;
          bg.style.borderWidth = bw;
        }
      } else {
        bg.classList.remove('poly-border');
        bg.style.removeProperty('--bw');
        bg.style.removeProperty('--bc');
        bg.style.borderWidth = '0px';
      }
      // контент
      if (/^https?:\/\//i.test(obj.val)) {
        const img = document.createElement('img');
        img.src = obj.val;
        content.appendChild(img);
        content.style.setProperty('--cw', IMG_BOX + 'px');
        content.style.setProperty('--ch', IMG_BOX + 'px');
        const shape = (STYLE.shape || 'rounded');
        const hasImageFrame = !!bgList.length;
        const padX = hasImageFrame ? 30 : 22;
        const padY = hasImageFrame ? 24 : 18;
        let W = IMG_BOX + padX*2 + PAD*2;
        let H = IMG_BOX + padY*2 + PAD*2;
        if (shape === 'circle' || shape === 'diamond' || shape === 'star') {
          const S = Math.max(W, H);
          W = H = S;
        }
        el.style.width  = W + 'px';
        el.style.height = H + 'px';
        img.onload = () => { el.style.width = W + 'px'; el.style.height = H + 'px'; };
      } else if ((cfg.language||'') === 'math'){
        const span = document.createElement('span');
        span.textContent = `\\(${obj.val}\\)`;
        span.style.color = TEXT_COLOR;
        span.style.fontSize = `${FONT_SIZE}px`;
        span.style.fontFamily = `${FONT}, system-ui, sans-serif`;
        content.appendChild(span);
      } else {
        const span = document.createElement('span');
        span.textContent = String(obj.val);
        span.style.color = TEXT_COLOR;
        span.style.fontFamily = `${FONT}, system-ui, sans-serif`;
        span.style.fontSize = `${FONT_SIZE}px`;
        content.appendChild(span);
      }

      const DIR = (cfg.direction || 'down');
      const gw = game.clientWidth;
      const gh = game.clientHeight;
      let x, y;
      const MARGIN = 20;

      if (DIR === 'down' || DIR === 'up') {
        x = (typeof forcedX === 'number') ? forcedX : rnd(MARGIN, gw - MARGIN);
        y = (DIR === 'down') ? -160 : (gh + 160);
      } else if (DIR === 'left' || DIR === 'right') {
        y = rnd(16, gh - 140);
        x = (DIR === 'left') ? -220 : (gw + 220);
      } else { // random
        x = rnd(MARGIN, gw - MARGIN - 160);
        y = rnd(40, gh - 160);
      }

      el.style.left = x + 'px';
      el.style.top  = y + 'px';
      game.appendChild(el);
      fitGeometryBox(el);
      autoFitText(el, FONT_SIZE, 12);
      if ((cfg.language||'') === 'math'){
        MathJax.typesetPromise([el]).then(()=>{
          fitGeometryBox(el);
          adjustX();
        });
      }

      const vel = SPEED.vel;
      const swayAmp = rnd(6, 22);
      const swayFreq = rnd(0.003, 0.008);
      let t = 0;
      let alive = true;

      // random‑вектор движения для режима "Рандом"
      const baseRandVel = vel * 0.45;
      let dx = rnd(-baseRandVel, baseRandVel);
      let dy = rnd(-baseRandVel, baseRandVel);
      if (Math.abs(dx) < 0.2) dx = 0.2 * Math.sign(Math.random()*2-1);
      if (Math.abs(dy) < 0.2) dy = 0.2 * Math.sign(Math.random()*2-1);

      function adjustX(){
        if (!(DIR === 'down' || DIR === 'up')) return;
        const W = el.offsetWidth;
        const safe = swayAmp;
        const min = MARGIN + safe;
        const max = Math.max(min, gw - W - MARGIN - safe);
        x = clamp(x, min, max);
        el.style.left = x + 'px';
      }
      adjustX();

      function step(){
        if(!alive) return;
        // если сейчас проигрывается caught/ошибка — даём анимации спокойно идти
        if (el.classList.contains('caught') || el.classList.contains('shake')){
          requestAnimationFrame(step);
          return;
        }
        t += 1;
        if (DIR === 'down'){
          y += vel;
          const tx = Math.sin(t*swayFreq) * swayAmp;
          el.style.top = y+'px';
          el.style.transform = `translateX(${tx}px)`;
          if (y > gh + 200){
            alive = false;
            if (el.dataset.good === '1') missedCorrect++;
            el.remove(); return;
          }
        } else if (DIR === 'up'){
          y -= vel;
          const tx = Math.sin(t*swayFreq) * swayAmp;
          el.style.top = y+'px';
          el.style.transform = `translateX(${tx}px)`;
          if (y < -200){
            alive = false;
            if (el.dataset.good === '1') missedCorrect++;
            el.remove(); return;
          }
        } else if (DIR === 'left'){
          x += vel;
          const ty = Math.sin(t*swayFreq) * swayAmp;
          el.style.left = x+'px';
          el.style.transform = `translateY(${ty}px)`;
          if (x > gw + 200){
            alive = false;
            if (el.dataset.good === '1') missedCorrect++;
            el.remove(); return;
          }
        } else if (DIR === 'right'){
          x -= vel;
          const ty = Math.sin(t*swayFreq) * swayAmp;
          el.style.left = x+'px';
          el.style.transform = `translateY(${ty}px)`;
          if (x < -200){
            alive = false;
            if (el.dataset.good === '1') missedCorrect++;
            el.remove(); return;
          }
        } else { // random
          x += dx;
          y += dy;

          const W = el.offsetWidth;
          const H = el.offsetHeight;

          if (x < MARGIN){
            x = MARGIN; dx = Math.abs(dx) + rnd(0,0.15);
          }
          if (x > gw - W - MARGIN){
            x = gw - W - MARGIN; dx = -Math.abs(dx) - rnd(0,0.15);
          }
          if (y < 30){
            y = 30; dy = Math.abs(dy) + rnd(0,0.15);
          }
          if (y > gh - H - 30){
            y = gh - H - 30; dy = -Math.abs(dy) - rnd(0,0.15);
          }
          // мягкое дрейфование
          if (Math.abs(dx) < baseRandVel*0.3) dx += (Math.random()-0.5)*baseRandVel*0.3;
          if (Math.abs(dy) < baseRandVel*0.3) dy += (Math.random()-0.5)*baseRandVel*0.3;
          dx = clamp(dx, -baseRandVel, baseRandVel);
          dy = clamp(dy, -baseRandVel, baseRandVel);

          el.style.left = x+'px';
          el.style.top  = y+'px';
          // transform тут не трогаем — он только для scale при hover
        }
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);

      // hover‑эффекты только для режима Рандом
      if ((cfg.direction || 'down') === 'random'){
        el.addEventListener('mouseenter', ()=>{
          dx *= 0.35;
          dy *= 0.35;
          el.style.transform = 'scale(1.12)';
        });
        el.addEventListener('mouseleave', ()=>{
          dx *= 2.2;
          dy *= 2.2;
          el.style.transform = 'scale(1)';
        });
      }

      el.addEventListener('click', (ev)=>{
        if (!running) return;
        if (!alive) return;
        ev.stopPropagation();
        const isGood = el.dataset.good === '1';
        if (isGood){
          alive = false;
          hits++;
          streak++;
          const bonus = Math.max(0, streak-1) * 2;
          const pts = SPEED.basePts + bonus;
          score += pts;
          hudScore.textContent = String(score);
          foundCorrect.add(el.dataset.value);
          el.classList.remove('shake','tint-red');
          el.classList.add('caught');
          playPop(el);
          smallFireworkAt(el);
          popScore(el, '+'+pts);
          setTimeout(()=> el.remove(), 580);
          if (foundCorrect.size >= neededCorrect){
            finishLevelAfter(el);
          }
        } else {
          wrongClicks++;
          streak = 0;
          try{
            wrongSound.currentTime=0;
            wrongSound.play().catch(()=>{});
          }catch(_){}
          const penalty = Math.max(5, Math.round(SPEED.basePts * 0.6));
          score = Math.max(0, score - penalty);
          hudScore.textContent = String(score);
          el.classList.add('tint-red','shake');
          popScore(el, '−'+penalty, '#ff4d6a');
          setTimeout(()=>{ el.classList.remove('tint-red','shake'); }, 450);
        }
      });
    }
    function finishLevelAfter(clickedEl){
      stopSpawning();
      setTimeout(()=>{
        const totalLevels = (cfg.levels || []).length;
        if (currentLevel >= totalLevels){
          clearItems();
          fireworks();
          try{ winSound.currentTime=0; winSound.play(); }catch(_){}
          showGameCompleteOverlay({
            score,
            hits,
            wrong: wrongClicks,
            missed: missedCorrect
          });
        } else {
          clearItems();
          startLevel();
        }
      }, 650);
    }
    /* ===== Геометрия / автофит ===== */
    function fitGeometryBox(el){
      const STYLE = cfg.style || {};
      const content = el.querySelector('.content');
      if (content && content.style.getPropertyValue('--cw')) return;
      const shape = STYLE.shape || 'rounded';
      el.style.width = ''; el.style.height='';
      const r = content.getBoundingClientRect();
      const hasImageFrame =
        String(STYLE.bgImage||'').trim() ||
        (Array.isArray(STYLE.bgImages) && STYLE.bgImages.length>0);
      const padX = hasImageFrame ? 30 : 22;
      const padY = hasImageFrame ? 24 : 18;
      let W = Math.ceil(r.width + padX*2);
      let H = Math.ceil(r.height + padY*2);
      if (shape === 'circle' || shape === 'diamond' || shape === 'star'){
        const S = Math.max(W, H);
        W = H = Math.ceil(S + 16);
      }
      el.style.width = W + 'px';
      el.style.height = H + 'px';
    }
    function autoFitText(el, startPx, minPx){
      const span = el.querySelector('.content span');
      if(!span) return;
      let fs = startPx;
      const STYLE = cfg.style || {};
      const pad = STYLE.pad ?? 18;
      const maxW = el.clientWidth - pad*2;
      const maxH = el.clientHeight - pad*2;
      const fits = ()=> {
        const rr = span.getBoundingClientRect();
        return (rr.width <= maxW && rr.height <= maxH);
      };
      while (fs > minPx){
        span.style.fontSize = fs + 'px';
        if (fits()) break;
        fs -= 1;
      }
    }
    /* ===== Эффекты ===== */
    function playPop(el){
      try{
        popSound.currentTime = 0;
        popSound.play().catch(()=>{});
      }catch(_){}
      const r = el.getBoundingClientRect();
      for(let i=0;i<14;i++){
        const s = document.createElement('div');
        s.className = 'sparkle';
        s.style.left = (r.left + r.width/2) + 'px';
        s.style.top  = (r.top  + r.height/2) + 'px';
        const angle = Math.random() * Math.PI * 2;
        const dist = 40 + Math.random()*70;
        s.style.setProperty('--dx', (Math.cos(angle)*dist) + 'px');
        s.style.setProperty('--dy', (Math.sin(angle)*dist) + 'px');
        document.body.appendChild(s);
        setTimeout(()=> s.remove(), 1000);
      }
    }
    function popScore(el, text, color){
      const r = el.getBoundingClientRect();
      const node = document.createElement('div');
      node.className = 'score-float';
      node.style.left = (r.left + r.width/2) + 'px';
      node.style.top  = (r.top + 8) + 'px';
      node.style.color = color || 'var(--ui)';
      node.textContent = text;
      document.body.appendChild(node);
      setTimeout(()=> node.remove(), 900);
    }
    function smallFireworkAt(el){
      const rect = el.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top  + rect.height/2;
      const parts = 16;
      for(let i=0;i<parts;i++){
        const p = document.createElement('div');
        p.className='firework';
        p.style.left = cx+'px'; p.style.top = cy+'px';
        const angle = (Math.PI*2) * (i/parts) + Math.random()*0.3;
        const dist = 30 + Math.random()*40;
        p.style.setProperty('--tx', (Math.cos(angle)*dist)+'px');
        p.style.setProperty('--ty', (Math.sin(angle)*dist)+'px');
        p.style.background = `hsl(${Math.floor(Math.random()*360)},90%,70%)`;
        document.body.appendChild(p);
        setTimeout(()=> p.remove(), 900);
      }
    }
    function fireworks(count=18){
      const W = window.innerWidth, H = window.innerHeight;
      for(let k=0;k<count;k++){
        const x = Math.random()*W*0.8 + W*0.1;
        const y = Math.random()*H*0.5 + H*0.1;
        const parts = 26;
        for(let i=0;i<parts;i++){
          const p = document.createElement('div');
          p.className='firework';
          p.style.left = x+'px'; p.style.top = y+'px';
          const angle = (Math.PI*2) * (i/parts) + Math.random()*0.2;
          const dist = 60 + Math.random()*120;
          p.style.setProperty('--tx', (Math.cos(angle)*dist)+'px');
          p.style.setProperty('--ty', (Math.sin(angle)*dist)+'px');
          p.style.background = `hsl(${Math.floor(Math.random()*360)},90%,70%)`;
          document.body.appendChild(p);
          setTimeout(()=> p.remove(), 900);
        }
      }
    }
  </script>
</body>
</html>
